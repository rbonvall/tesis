\chapter{GPU implementation}
\label{ch:implementation}

This chapter describes how the simulation was implemented on the GPU.

\section{Work distribution}
\label{sec:work-distribution}

The simulation of the Lamb-Oseen vortex
with the algorithm described in chapter~\ref{ch:vm-design}
amounts to the numerical integration
of the convection and diffusion equations
for each of the particles of the system:
\begin{align}
    %\label{eq:integration}
    x_p^{(n + 1)} &= x_p^{(n)} + u_p^{(n)}\, δt, \\
    y_p^{(n + 1)} &= y_p^{(n)} + v_p^{(n)}\, δt, \\
    α_p^{(n + 1)} &= α_p^{(n)} + \dot{α}_p^{(n)}\, δt.
\end{align}

At every time step~\(n\), the values of \(u\), \(v\) and \(\dot{α}\)
must be evaluated as a function of all other particles:
\begin{align}
    %\label{eq:evaluation}
    (u_p, v_p) &= \sum_q α_p \K_ε(\x_p - \x_q) \\
    \dot{α}_p  &= νε^{-2} \sum_q [α_q - α_p]\,η_ε(\x_p - \x_q)
\end{align}
The inner terms of both summations have to be computed
for every pair of particles.

The reference algorithm for evaluating
this kind of computation on the GPU
is the one by Nyland et.~al~\cite[\S31]{gems3},
which shows how to integrate a body system under gravitational interaction.


\newcommand{\nrbodies}{64}
\newcommand{\lastbody}{63}
\newcommand{\nrtiles}{8}
\newcommand{\lasttile}{7}
\newcommand{\nrtilebodies}{8}
\newcommand{\lasttilebody}{7}

\tikzstyle{innergrid}=[gray!80]
\tikzstyle{tile}=[green!60!black, thick]
\tikzstyle{sync}=[red!60!black, thick, dashed]
\tikzstyle{thread}=[->, decorate, decoration={snake, amplitude=.6}]
\tikzstyle{examplecell}=[fill=orange, opacity=.5]
\tikzstyle{kernelcall}=[rounded corners=2pt, very thick]
\tikzstyle{kernelarrow}=[->, thick, out=90, in=180]
\tikzstyle{imglabel}=[anchor=west, text opacity=1.0, fill=white, fill opacity=.5,
                      text height=1ex, text depth=.25ex, rounded corners]

\begin{figure}
  \centering
  \begin{tikzpicture}[scale=.2, yscale=-1, font=\small]

    \foreach \tile in {0,1,...,\lasttile} {
      \def\ybot{9 * \tile}
      \draw[innergrid] (0, \ybot) grid      ++(\nrbodies, \nrtilebodies);
      \draw[tile]      (0, \ybot) rectangle ++(\nrbodies, \nrtilebodies);
      \draw (5 + \nrbodies, \ybot + \nrtilebodies / 2)
          node[anchor=center] { block $\tile$ };

      \foreach \syncpoint in {1,...,7}
        \draw[sync] (\nrtiles * \syncpoint, \ybot) -- ++(0, \nrtilebodies);
    }

    \def\block{1}
    \def\to{43}
    \foreach \k in {0,...,3}
      \draw [thread] (0.5, 9 * \block + 0.5 + \k) -- ++(\to - 1, 0);
    \def\to{42}
    \foreach \k in {4,...,\lasttilebody}
      \draw [thread] (0.5, 9 * \block + 0.5 + \k) -- ++(\to - 1, 0);

    \def\block{2}
    \def\to{12}
    \foreach \k in {0,1}
      \draw [thread] (0.5, 9 * \block + 0.5 + \k) -- ++(\to - 1, 0);
    \def\to{11}
    \foreach \k in {2,...,\lasttilebody}
      \draw [thread] (0.5, 9 * \block + 0.5 + \k) -- ++(\to - 1, 0);

    \def\block{3}
    \def\to{24}
    \foreach \k in {0,...,\lasttilebody}
      \draw [thread] (0.5, 9 * \block + 0.5 + \k) -- ++(\to - 0.5, 0);

    \def\block{4}
    \def\to{45}
    \foreach \k in {0,1,3,4,...,\lasttilebody}
      \draw [thread, gray] (0.5, 9 * \block + 0.5 + \k) -- ++(\to - 1, 0);

    % draw kernel calls
    \def\currentx{44}
    \def\currenty{9 * \block + 2}
    \draw[kernelcall, brown, pattern=north east lines, pattern color=brown]
      (   0, \currenty - .2) rectangle ++(64, 1.4);
    \draw[kernelcall, blue!50!black, pattern=north west lines, pattern color=blue!50!black]
      (  40, \currenty - .1) rectangle ++( 8, 1.2);
    \draw[kernelcall, orange, fill]
      (\currentx, \currenty) rectangle ++( 1, 1);
    \node[anchor=base] (interactionanchor) at (\currentx + 0.5, \currenty + 1.0) {};
    \node[anchor=base] (tileanchor)        at (\currentx - 2.5, \currenty + 1.1) {};
    \node[anchor=base] (evalanchor)        at (\currentx - 8.5, \currenty + 1.2) {};

    \node[imglabel] (interactionlabel) at (49.5, \currenty +  4.5) {\textit{interaction}};
    \node[imglabel] (tilelabel)        at (49.5, \currenty +  7.5) {\textit{tile\_computation}};
    \node[imglabel] (evallabel)        at (49.5, \currenty + 10.5) {\textit{evaluation}};

    \draw[kernelarrow, orange]        (interactionanchor.base) to (interactionlabel);
    \draw[kernelarrow, blue!50!black] (tileanchor.base)        to (tilelabel);
    \draw[kernelarrow, brown]         (evalanchor.base)        to (evallabel);

    % draw active thread
    \draw [thread] (0.5, 9 * \block + 0.5 + 2) -- ++(\to - 1, 0);

    \def\examplex{21}
    \def\exampley{5}
    \draw[examplecell] (\examplex, \exampley) rectangle ++(1, 1);
    \node[anchor=base] (cellanchor) at (\examplex + .5, \exampley + .5) {};

    \draw (35, -5) node[anchor=west] (interaction) {
      \(
       \left\{
       \begin{aligned}
         {\vec u}_{pq} &= α_q\,\K_ε(\x_p - \x_q) \\
         \dot{α}_{pq}  &= νε^{-2} [α_q - α_p]\,η_ε(\x_p - \x_q) \\
       \end{aligned}
       \right.
      \)
    };
    \draw[->, out=-45, in=180] (cellanchor.base) to (interaction);
    \node[imglabel, anchor=east]  (plabel) at (\examplex - 7,  \exampley + .5) {\((x_p, y_p, α_p)\)};
    \node[imglabel, anchor=south] (qlabel) at (\examplex + .5, -1) {\((x_q, y_q, α_q)\)};
    \draw[dotted, very thick] (plabel) -- (cellanchor.base);
    \draw[dotted, very thick] (qlabel) -- (cellanchor.base);

    \foreach \block in {1,2,3,4} {
      \foreach \thread in {0,...,7} {
        \node[font=\tiny, anchor=east] at (0, .5 + \block * 9 + \thread) {\thread};
      }
    }

  \end{tikzpicture}
  \label{fig:nbody-tiles}
  \caption{Work distribution among threads and thread blocks
    for a system of \protect{\(N = 64\)} particles and
    a grid of \protect{\(B = 8\)} thread blocks.
    Each small square represents an interaction between two particles.
    Dashed lines show where threads synchronize and fetch a set of particles.
    Waved lines show how threads sequentially compute interactions along a row.
    The rectangles in block 4 show which device kernels are in execution
    during the computation of a particle pair interaction.
  }
\end{figure}

